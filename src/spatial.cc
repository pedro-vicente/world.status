#include "spatial.hh"
#include "duckdb.hpp"
#include <iostream>
#include <sstream>

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Point2D
/////////////////////////////////////////////////////////////////////////////////////////////////////

Point2D::Point2D() : x(0), y(0) {}

Point2D::Point2D(double x_, double y_) : x(x_), y(y_) {}

std::string Point2D::to_wkt() const
{
  std::ostringstream oss;
  oss << "POINT(" << x << " " << y << ")";
  return oss.str();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// BoundingBox
/////////////////////////////////////////////////////////////////////////////////////////////////////

BoundingBox::BoundingBox() : min_x(0), min_y(0), max_x(0), max_y(0) {}

BoundingBox::BoundingBox(double minx, double miny, double maxx, double maxy)
  : min_x(minx), min_y(miny), max_x(maxx), max_y(maxy)
{
}

double BoundingBox::area() const
{
  return (max_x - min_x) * (max_y - min_y);
}

bool BoundingBox::contains(const Point2D& p) const
{
  return p.x >= min_x && p.x <= max_x && p.y >= min_y && p.y <= max_y;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// SpatialClient
/////////////////////////////////////////////////////////////////////////////////////////////////////

SpatialClient::SpatialClient()
{
  db = new duckdb::DuckDB(nullptr);
  conn = new duckdb::Connection(*db);
}

SpatialClient::SpatialClient(const std::string& db_path)
{
  db = new duckdb::DuckDB(db_path);
  conn = new duckdb::Connection(*db);
}

SpatialClient::~SpatialClient()
{
  delete conn;
  delete db;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// init_spatial
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::init_spatial()
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query("INSTALL spatial");
  if (result->HasError())
  {
    return false;
  }

  result = conn->Query("LOAD spatial");
  if (result->HasError())
  {
    return false;
  }
  return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// query
/////////////////////////////////////////////////////////////////////////////////////////////////////

void SpatialClient::query(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  if (result->HasError())
  {
  }
  else
  {
    std::cout << result->ToString() << std::endl;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// execute
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::execute(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  return !result->HasError();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// query_string
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::query_string(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  if (result->HasError() || result->RowCount() == 0)
  {
    return "";
  }
  duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
  if (!chunk || chunk->size() == 0)
  {
    return "";
  }
  return chunk->GetValue(0, 0).ToString();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// query_double
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::query_double(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  if (result->HasError() || result->RowCount() == 0)
  {
    return 0.0;
  }
  duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
  if (!chunk || chunk->size() == 0)
  {
    return 0.0;
  }
  return chunk->GetValue(0, 0).GetValue<double>();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// query_bool
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::query_bool(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  if (result->HasError() || result->RowCount() == 0)
  {
    return false;
  }
  duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
  if (!chunk || chunk->size() == 0)
  {
    return false;
  }
  return chunk->GetValue(0, 0).GetValue<bool>();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// query_int
/////////////////////////////////////////////////////////////////////////////////////////////////////

int SpatialClient::query_int(const std::string& sql)
{
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  if (result->HasError() || result->RowCount() == 0)
  {
    return 0;
  }
  duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
  if (!chunk || chunk->size() == 0)
  {
    return 0;
  }
  return chunk->GetValue(0, 0).GetValue<int>();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// escape
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::escape(const std::string& s)
{
  std::string result;
  for (size_t idx = 0; idx < s.size(); idx++)
  {
    if (s[idx] == '\'')
    {
      result += "''";
    }
    else
    {
      result += s[idx];
    }
  }
  return result;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// geometry creation
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_point
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_point(double x, double y)
{
  std::ostringstream sql;
  sql << "SELECT ST_AsText(ST_Point(" << x << ", " << y << "))";
  return query_string(sql.str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_geom_from_text
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_geom_from_text(const std::string& wkt)
{
  std::string sql = "SELECT ST_AsText(ST_GeomFromText('" + escape(wkt) + "'))";
  return query_string(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_makeline
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_makeline(const std::vector<Point2D>& points)
{
  if (points.size() < 2) return "";
  std::ostringstream wkt;
  wkt << "LINESTRING(";
  for (size_t idx = 0; idx < points.size(); idx++)
  {
    if (idx > 0) wkt << ", ";
    wkt << points[idx].x << " " << points[idx].y;
  }
  wkt << ")";
  return st_geom_from_text(wkt.str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_makepolygon
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_makepolygon(const std::vector<Point2D>& ring)
{
  if (ring.size() < 3) return "";
  std::ostringstream wkt;
  wkt << "POLYGON((";
  for (size_t idx = 0; idx < ring.size(); idx++)
  {
    if (idx > 0) wkt << ", ";
    wkt << ring[idx].x << " " << ring[idx].y;
  }
  if (ring[0].x != ring[ring.size() - 1].x || ring[0].y != ring[ring.size() - 1].y)
  {
    wkt << ", " << ring[0].x << " " << ring[0].y;
  }
  wkt << "))";
  return st_geom_from_text(wkt.str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_make_envelope
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_make_envelope(double min_x, double min_y, double max_x, double max_y)
{
  std::ostringstream sql;
  sql << "SELECT ST_AsText(ST_MakeEnvelope("
    << min_x << ", " << min_y << ", " << max_x << ", " << max_y << "))";
  return query_string(sql.str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// properties
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_x
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::st_x(const std::string& geom)
{
  std::string sql = "SELECT ST_X(ST_GeomFromText('" + escape(geom) + "'))";
  return query_double(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_y
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::st_y(const std::string& geom)
{
  std::string sql = "SELECT ST_Y(ST_GeomFromText('" + escape(geom) + "'))";
  return query_double(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_area
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::st_area(const std::string& geom)
{
  std::string sql = "SELECT ST_Area(ST_GeomFromText('" + escape(geom) + "'))";
  return query_double(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_length
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::st_length(const std::string& geom)
{
  std::string sql = "SELECT ST_Length(ST_GeomFromText('" + escape(geom) + "'))";
  return query_double(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_npoints
/////////////////////////////////////////////////////////////////////////////////////////////////////

int SpatialClient::st_npoints(const std::string& geom)
{
  std::string sql = "SELECT ST_NPoints(ST_GeomFromText('" + escape(geom) + "'))";
  return query_int(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_isvalid
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::st_isvalid(const std::string& geom)
{
  std::string sql = "SELECT ST_IsValid(ST_GeomFromText('" + escape(geom) + "'))";
  return query_bool(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_centroid
/////////////////////////////////////////////////////////////////////////////////////////////////////

Point2D SpatialClient::st_centroid(const std::string& geom)
{
  std::string sql = "SELECT ST_X(ST_Centroid(ST_GeomFromText('" + escape(geom) + "'))), "
    "ST_Y(ST_Centroid(ST_GeomFromText('" + escape(geom) + "')))";
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  Point2D p;
  if (!result->HasError() && result->RowCount() > 0)
  {
    duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
    if (chunk && chunk->size() > 0)
    {
      p.x = chunk->GetValue(0, 0).GetValue<double>();
      p.y = chunk->GetValue(1, 0).GetValue<double>();
    }
  }
  return p;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_extent
/////////////////////////////////////////////////////////////////////////////////////////////////////

BoundingBox SpatialClient::st_extent(const std::string& geom)
{
  std::string sql = "SELECT ST_XMin(g), ST_YMin(g), ST_XMax(g), ST_YMax(g) "
    "FROM (SELECT ST_GeomFromText('" + escape(geom) + "') as g)";
  duckdb::unique_ptr<duckdb::MaterializedQueryResult> result = conn->Query(sql);
  BoundingBox bbox;
  if (!result->HasError() && result->RowCount() > 0)
  {
    duckdb::unique_ptr<duckdb::DataChunk> chunk = result->Fetch();
    if (chunk && chunk->size() > 0)
    {
      bbox.min_x = chunk->GetValue(0, 0).GetValue<double>();
      bbox.min_y = chunk->GetValue(1, 0).GetValue<double>();
      bbox.max_x = chunk->GetValue(2, 0).GetValue<double>();
      bbox.max_y = chunk->GetValue(3, 0).GetValue<double>();
    }
  }
  return bbox;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// relationships
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_intersects
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::st_intersects(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_Intersects(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "'))";
  return query_bool(sql);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_contains
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::st_contains(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_Contains(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "'))";
  return query_bool(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_within
/////////////////////////////////////////////////////////////////////////////////////////////////////

bool SpatialClient::st_within(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_Within(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "'))";
  return query_bool(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_distance
/////////////////////////////////////////////////////////////////////////////////////////////////////

double SpatialClient::st_distance(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_Distance(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "'))";
  return query_double(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// operations
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_intersection
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_intersection(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_AsText(ST_Intersection(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "')))";
  return query_string(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_union
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_union(const std::string& geom1, const std::string& geom2)
{
  std::string sql = "SELECT ST_AsText(ST_Union(ST_GeomFromText('" + escape(geom1) + "'), "
    "ST_GeomFromText('" + escape(geom2) + "')))";
  return query_string(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_buffer
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_buffer(const std::string& geom, double distance)
{
  std::ostringstream sql;
  sql << "SELECT ST_AsText(ST_Buffer(ST_GeomFromText('" << escape(geom) << "'), " << distance << "))";
  return query_string(sql.str());
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_convexhull
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_convexhull(const std::string& geom) {
  std::string sql = "SELECT ST_AsText(ST_ConvexHull(ST_GeomFromText('" + escape(geom) + "')))";
  return query_string(sql);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// st_asgeojson
/////////////////////////////////////////////////////////////////////////////////////////////////////

std::string SpatialClient::st_asgeojson(const std::string& geom)
{
  std::string sql = "SELECT ST_AsGeoJSON(ST_GeomFromText('" + escape(geom) + "'))";
  return query_string(sql);
}
